\section{Case Studies}\label{sec:case-studies}
This section introduces livelits from the client programmer's perspective by way of 
two domain-specific case studies:
a course grade assignment case study in Sec.~\ref{sec:live-grading} 
and an image transformation case study in Sec.~\ref{sec:image-transformation}. 
We also briefly mention several other examples in Sec.~\ref{sec:additional-examples}. 
These case studies and examples have been implemented\todo{make this not a lie}{}
in Hazel, a browser-based live programming environment for a pure typed functional language in the
ML family, with which we assume basic familiarity.\todo{cite Elm tutorial for readers who are not familiar?}{} 

\subsection{Case Study: Grading with Livelits}\label{sec:live-grading}
\begin{figure}
\begin{lstlisting}
let grades = $dataframe in 
            A1          A2          A3          A4       Midterm      Final  +
  Cyrus
  Nick
  David
    + 
let averages = compute_averages(grades) in 
let cutoffs = $cutoffs(averages) in 

  |---------------------------------------------------|

format_for_university(assign_grades(averages, cutoffs))
\end{lstlisting}
\caption{Grading Example}
\label{fig:grading}
\end{figure}

Consider this commonplace scenario: an instructor needs 
(1) to record numeric grades for various assignments and exams, and 
(2) to visualize and perform various computations with these numeric grades 
in order ultimately to assign final letter grades (\textbf{A} through \textbf{F}) to the students in the course.

Perhaps the most common end-user application in this domain is the spreadsheet.
A spreadsheet allows the instructor to record student grades using a natural tabular interface,
visualize this data in one of a finite number of styles, and perform basic computations on this data,
with results updated live, i.e. automatically after each cell has been edited. 
However, these affordances are limited. It is difficult to package up common operations and workflows 
into reusable libraries, interact with the data using domain-specific visualizations, 
and perform operations that have not been anticipated by the designers of the spreadsheet system 
(e.g. operations that prepare the data in an idiosyncratic format suitable for automated submission 
to the university's grading system). 
General-purpose programming languages equipped with suitable libraries for working with numeric data
are flexible enough to handle these scenarios, but users of these languages 
sacrifice the ability to receive live feedback and directly manipulate the data and visualizations thereof.

Livelits are able to address this tension. 
Fig.~\ref{fig:grading} shows a Hazel program where the user has:\todo{label each of these 1-5 in figure?}{}
\begin{enumerate}
\item directly recorded numeric \li{grades} for each student using a livelit, \li{\$dataframe}, that implements a tabular spreadsheet-like interface suitable for this purpose, 
\item programmatically computed the overall \li{averages} for each student by calling a function, \li{compute_averages}, defined in a library (not shown), 
\item determined the \li{cutoffs} between letter grades by directly manipulating a livelit that provides a drag-and-drop interface superimposed on a visualization of the grade distribution, 
\item programmatically assigned letter grades to each student based on the cutoffs determined by the livelit in (3) by calling a library function, \li{assign_grades}, and 
\item formatted the final grade assignments in a manner suitable for submission to a university system by calling another library function, \li{format_for_university}.
\end{enumerate}

\subsubsection{Overview}\label{sec:live-grading-overview}
Talk about the scenario

Live matrix: what is a matrix structurally? (data frame? list of lists?) + how does liveness work
+ overview of hygiene guarantees

Grade cutoffs: how does it work wrt liveness? (do we use a parameter here instead of a splice?) -- 
focus on domain-specific benefits here.

\subsection{Case Study: Image Transformations}\label{sec:image-transformation}
Show example of an image transformation pipeline going through livelits

This might also benefit from Parameterization

Show multiple calls with different example images + closure selector UIs

Go into more detail about how evaluation works + fill-and-resume mechanics (and efficiency nod)

Talk about probes?

\subsection{Additional Examples}\label{sec:additional-examples}
It would be nice to have a gallery-style figure and a brief overview of some other case studies
and how they exercise the novel features of the livelits mechanism. Maybe some statistics on how
many lines of code it took.

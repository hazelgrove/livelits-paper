\section{Case Studies}\label{sec:case-studies}
This section introduces livelits from the client programmer's perspective by way of 
two domain-specific case studies:
a course grade assignment case study in Sec.~\ref{sec:live-grading} 
and an image transformation case study in Sec.~\ref{sec:image-transformation}. 
We also briefly mention several other examples in Sec.~\ref{sec:additional-examples}. 
These case studies and examples have been implemented\todo{make this not a lie}{}
in Hazel, a browser-based live programming environment for a pure typed functional language in the
ML family, with which we assume basic familiarity.\todo{cite Elm tutorial for readers who are not familiar?}{} 

\subsection{Case Study: Grading with Livelits}\label{sec:live-grading}
\begin{figure}
\begin{lstlisting}
let grades = $dataframe in 
            A1          A2          A3          A4       Midterm      Final  +
  Cyrus
  Nick
  David
    + 
let averages = compute_averages(grades) in 
let cutoffs = $cutoffs(averages) in 

  |---------------------------------------------------|

format_for_university(assign_grades(averages, cutoffs))
\end{lstlisting}
\caption{Grading Example}
\label{fig:grading}
\end{figure}

Consider this commonplace scenario: an instructor needs 
(1) to record numeric grades for various assignments and exams, and 
(2) to visualize and perform various computations with these numeric grades 
in order ultimately to assign final letter grades (\textbf{A} through \textbf{F}) to the students in the course.

Perhaps the most common end-user application in this domain is the spreadsheet.
A spreadsheet allows the instructor to record student grades using a natural tabular interface,
visualize this data in one of a finite number of styles, and perform basic computations on this data,
with results updated live, i.e. automatically after each cell has been edited. 
However, these affordances are limited. It is difficult to package up common operations and workflows 
into reusable libraries, interact with the data using domain-specific visualizations, 
and perform operations that have not been anticipated by the designers of the spreadsheet system 
(e.g. operations that prepare the data in an idiosyncratic format suitable for automated submission 
to the university's grading system). 
General-purpose programming languages equipped with suitable libraries for working with numeric data
are flexible enough to handle these scenarios, but users of these languages 
sacrifice the ability to receive live feedback and directly manipulate the data and visualizations thereof.

Livelits are able to address this tension. 
Fig.~\ref{fig:grading} shows a Hazel program where the user has:\todo{label each of these 1-5 in figure?}{}
\begin{enumerate}
\item recorded numeric \li{grades} for each student using a livelit, \li{\$dataframe}, that implements a tabular user interface with support for live evaluation of the Hazel expressions in cells, 
\item programmatically computed the overall \li{averages} for each student by applying a function, \li{compute_averages}, defined in a library  (not shown) shared between multiple courses, 
\item determined reasonable \li{cutoffs} between letter grades by directly manipulating a livelit that offers a domain-specific drag-and-drop interface superimposed on a live visualization of the grade distribution 
(for the sake of space, we plot dots rather than a full histogram)\todo{should we do a histogram?}{}, 
\item programmatically assigned letter grades to each student based on the \li{cutoffs} determined in step (3) by calling another shared library function, \li{assign_grades}, 
\item formatted the final grade assignments in a manner suitable for submission to the university system by calling another shared library function, \li{format_for_university}.
\end{enumerate}

\subsubsection{Livelit Expansion} 
Livelit expressions are given dynamic meaning by expansion to core expressions, i.e. expressions that do not contain livelits.
For example, the expansion of Fig.~\ref{fig:grading} is:\todo{change code once figure is final}{}

\begin{lstlisting}
let grades = Dataframe (
  ["A1", "A2", "A3", "A4", "Midterm", "Final"],
  [
    ("Cyrus", [0.0, 0.0, 0.0, 0.0, 0.0]),
    ("Nick", [0.0, 0.0, 0.0, 0.0, 0.0]),
    ("David", [0.0, 0.0, 0.0, 0.0, 0.0])
  ]) in 
let averages = compute_averages(grades) in 
let cutoffs = (.A 90.0, .B 80.0, .C 70.0, .D 60.0) in 
format_for_university(assign_grades(averages, cutoffs))
\end{lstlisting}

The programmer can inspect this expansion in Hazel. 
Ideally, however, it would not be necessary to inspect the expansion 
(or the livelit implementation, which specifies the expansion logic and is discussed in Sec.~\ref{sec:livelit-definitions}) 
to reason about types and binding. 
After all, one does not need to look inside 
function bodies to reason about types and binding.
Instead, in the words of Reynolds\todo{cite}{}, 
``type structure is a syntactic discipline for maintaining levels of abstraction''.
The livelits mechanism supports reasoning abstractly about types and binding by 
several means.

To support abstract reasoning about the type of the expansion, 
livelit definitions declare an \emph{expansion type}.
The declarations of the two livelits in Fig.~\ref{fig:grading}, 
eliding their implementations, are:
\begin{lstlisting}[numbers=none]
livelit $dataframe at Dataframe { ... }
livelit $cutoffs(avgs: List(Float)) 
  at (.A Float, .B Float, .C Float, .D Float) { ... }
\end{lstlisting}
The expansion type of \li{\$dataframe} is \li{Dataframe} 
(a type classifying tabular floating point data together with string row and column keys, consistent with the expansion above)
and the expansion type of \li{\$cutoffs} is a labeled product of grade cutoffs (Hazel notates labels \li{.label}).
Hazel summarizes the typing information from the livelit definition for the programmer when the cursor is on the livelit's name, 
just as it displays a function's type when its name is under the cursor (not shown).\todo{could show if Hannah et al are finished}{}

\subsubsection{Typed Hygienic Splicing and Parameterization}\label{sec:splicing-and-parameterization}
Livelit expressions can include sub-expressions in one of two ways:
as parameters or as splices. 

\paragraph{Parameters}\label{sec:parameterization} Parameters appear immediately after the name of the applied livelit. 
For example, \li{averages} is provided as a parameter to \li{\$cutoffs} in Fig.~\ref{fig:grading}.
The livelit declares a fixed number of parameters and specifies their types in its declaration. 
For example, the declaration of \li{\$cutoffs} shown above specifies one parameter of type \li{List(Float)}
(the grades data to be plotted, see below).

Livelit abbreviations can partially apply parameters. Consider the slider livelit
from Fig.~\ref{fig:color}:
\begin{lstlisting}[numbers=none]
livelit $slider (min: Float) (max: Float) at Float { ... }
\end{lstlisting}
We can partially apply the first parameter as follows to define a parameterized non-negative slider livelit with one remaining parameter:
\begin{lstlisting}[numbers=none]
livelit $nnslider = $slider 0.0 in ...
\end{lstlisting}
Only livelits with no remaining parameters can be used to fill a hole.
So writing \li{\$nnslider} in expression position will not display the slider GUI. Instead, it will display as a ``missing livelit parameter'' error.%
\footnote{\label{footnote:typing}In Hazel, erroneous expressions are automatically placed inside holes so that they do not prevent other parts of the program from executing
\cite{HazelnutLive}.}

\paragraph{Splices}\label{sec:splices}
Spliced expressions (or \emph{splices}) appear directly inside the livelit GUI.
Splices can be filled with Hazel expressions of any form, including other livelit expressions, 
and all of Hazel's editing affordances are available when editing these expressions.
For example, each cell in the \li{\$dataframe} GUI in Fig.~\ref{fig:grading} 
has a corresponding splice, which appears in the formula bar at the top of the livelit 
when the user has selected that cell. 
The cell itself displays the live value of the spliced expression, 
following the example of spreadsheet interfaces 
(we return to live evaluation in Sec.~\ref{sec:live-evaluation} below).

The livelit provides an expected type for each splice.
For example, the splices for the row and column keys in Fig.~\ref{fig:grading} are expected to be expressions
of type \li{String}, and the remaining cells are expected to be expressions of type \li{Float}. 
Hazel surfaces this typing information for the programmer when the cursor is in a splice, 
so it is not necessary to inspect the expansion or the livelit implementation.
If an expression of invalid type is entered, it will display in an error hole as usual,
and in Hazel this will not prevent evaluation of other expressions (see Footnote \ref{footnote:typing}).

Unlike parameters, the number of splices is not fixed in the livelit declaration. Splices can be created, 
deleted, and filled through user interaction with the livelit. For example, clicking the \li{+} buttons
in Fig.~\ref{fig:grading} will create new rows or columns, which will in turn generate new splices.

\paragraph{Hygiene}\label{sec:hygiene}
Parameters and splices can both appear in the underlying expansion. For example,
the expansion of the \li{\$dataframe} livelit in Fig.~\ref{fig:grading} includes the 
spliced expressions that the client entered the cell contents and the row and column keys.
(Not every parameter or splice needs to appear in the expansion. For example,
the bounds provided to the \li{\$slider} livelit are used only to constrain the user 
interface, and do not appear directly in the expansion, which is simply a number literal.)

The client cannot know, without looking at the expansion or the livelit implementation, 
where in the expansion each parameter or splice will appear. This becomes relevant when 
the expansion places the parameter or splice under a binder, e.g. in the body of a function or let binding.
Na\"ively, this could cause inadvertent capture of the bound variable by a free variable 
in the parameter or splice. For example, consider a livelit that generates an expansion 
of the following form:
\begin{lstlisting}[numbers=none]
let len = strlen <splice1> in 
(<splice2>, <splice2> + 1)
\end{lstlisting}
Here, \li{<splice2>} appears under the binding of \li{len}. If the client enters an expression
for \li{<splice2>} that itself refers to a client-side binding of the same variable, \li{len},
it would na\"ively be captured. This sort of bug would difficult to debug, both for the provider
and the client. 

To avoid this situation, the livelit expansion mechanism 
maintains parameter and splice hygiene: parameters and splices are included in the expansion 
in a capture-avoiding manner.
Consequently, clients can reason abstractly about binding in splices: variables in splices
always refer to bindings visible to the client, rather than bindings that are hidden inside expansions.
(We discuss potentially relaxed variations of this discipline in Sec.~\ref{sec:discussion}).
\subsubsection{Live Evaluation}\label{sec:live-evaluation}

\subsection{Case Study: Image Transformations}\label{sec:image-transformation}
Show example of an image transformation pipeline going through livelits

This might also benefit from Parameterization

Show multiple calls with different example images + closure selector UIs

Go into more detail about how evaluation works + fill-and-resume mechanics (and efficiency nod)

Talk about probes?

\subsection{Additional Examples}\label{sec:additional-examples}
It would be nice to have a gallery-style figure and a brief overview of some other case studies
and how they exercise the novel features of the livelits mechanism. Maybe some statistics on how
many lines of code it took.

Ideas:
\begin{itemize}
  \item derivation trees like Joomy's system (\url{https://joom.github.io/proof-tree-builder/src/})
\end{itemize}
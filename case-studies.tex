\section{Case Studies}\label{sec:case-studies}
This section introduces livelits from the client programmer's perspective by way of 
two domain-specific case studies:
a course grade assignment case study in Sec.~\ref{sec:live-grading} 
and an image transformation case study in Sec.~\ref{sec:image-transformation}. 
We also briefly mention several other examples in Sec.~\ref{sec:additional-examples}. 
These case studies and examples have been implemented\todo{make this not a lie}{}
in Hazel, a browser-based live programming environment for a pure typed functional language in the
ML family, with which we assume basic familiarity.\todo{cite Elm tutorial for readers who are not familiar?}{} 

\subsection{Case Study: Grading with Livelits}\label{sec:live-grading}
\begin{figure}
\begin{lstlisting}
let grades = $dataframe in 
            A1          A2          A3          A4       Midterm      Final  +
  Cyrus
  Nick
  David
    + 
let averages = compute_averages(grades) in 
let cutoffs = $cutoffs(averages) in 

  |---------------------------------------------------|

format_for_university(assign_grades(averages, cutoffs))
\end{lstlisting}
\caption{Grading Example}
\label{fig:grading}
\end{figure}

Consider this commonplace scenario: an instructor needs 
(1) to record numeric grades for various assignments and exams, and 
(2) to visualize and perform various computations with these numeric grades 
in order ultimately to assign final letter grades (\textbf{A} through \textbf{F}) to the students in the course.

Perhaps the most common end-user application in this domain is the spreadsheet.
A spreadsheet allows the instructor to record student grades using a natural tabular interface,
visualize this data in one of a finite number of styles, and perform basic computations on this data,
with results updated live, i.e. automatically after each cell has been edited. 
However, these affordances are limited. It is difficult to package up common operations and workflows 
into reusable libraries, interact with the data using domain-specific visualizations, 
and perform operations that have not been anticipated by the designers of the spreadsheet system 
(e.g. operations that prepare the data in an idiosyncratic format suitable for automated submission 
to the university's grading system). 
General-purpose programming languages equipped with suitable libraries for working with numeric data
are flexible enough to handle these scenarios, but users of these languages 
sacrifice the ability to receive live feedback and directly manipulate the data and visualizations thereof.

Livelits are able to address this tension. 
Fig.~\ref{fig:grading} shows a Hazel program where the user has:\todo{label each of these 1-5 in figure?}{}
\begin{enumerate}
\item recorded numeric \li{grades} for each student using a livelit, \li{\$dataframe}, that implements a tabular user interface with support for live evaluation of the Hazel expressions in cells, 
\item programmatically computed the overall \li{averages} for each student by applying a function, \li{compute_averages}, defined in a library  (not shown) shared between multiple courses, 
\item determined reasonable \li{cutoffs} between letter grades by directly manipulating a livelit that offers a domain-specific drag-and-drop interface superimposed on a live visualization of the grade distribution 
(for the sake of space, we plot dots rather than a full histogram)\todo{should we do a histogram?}{}, 
\item programmatically assigned letter grades to each student based on the \li{cutoffs} determined in step (3) by calling another shared library function, \li{assign_grades}, 
\item formatted the final grade assignments in a manner suitable for submission to the university system by calling another shared library function, \li{format_for_university}.
\end{enumerate}

\subsubsection{Livelit Expansion} 
Livelit expressions are given dynamic meaning by expansion to standard expressions, i.e. expressions without livelits.
The expansion of Fig.~\ref{fig:grading} is:\todo{change code once figure is final}{}

\begin{lstlisting}
let grades = (
  ["A1", "A2", "A3", "A4", "Midterm", "Final"],
  ("Cyrus", [0.0, 0.0, 0.0, 0.0, 0.0]),
  ("Nick", [0.0, 0.0, 0.0, 0.0, 0.0]),
  ("David", [0.0, 0.0, 0.0, 0.0, 0.0])) in 
let averages = compute_averages(grades) in 
let cutoffs = (.A 90.0, .B 80.0, .C 70.0, .D 60.0) in 
format_for_university(assign_grades(averages, cutoffs))
\end{lstlisting}

The programmer can request to see this expansion in Hazel. 
Ideally, however, it would not be necessary to inspect the underlying expansion 
(or the livelit implementation, discussed in Sec.~\ref{sec:livelit-definitions}) 
to reason about types and binding. 
After all, one does not need to look inside 
function bodies to reason about types and binding.
Instead, in the words of Reynolds\todo{cite}{}, 
``type structure is a syntactic discipline for maintaining levels of abstraction''.
The livelits mechanism supports reasoning abstractly about types and binding by 
several means.

First, to support abstract reasoning about the type of the expansion, 
livelit definitions must specify an \emph{expansion type} in their declarations.
The declarations of the two livelits in Fig.~\ref{fig:grading}, 
eliding their implementations for now, are:
\begin{lstlisting}[numbers=none]
livelit $dataframe at Dataframe { ... }
livelit $cutoffs(averages: List(Float)) 
  at (.A Float, .B Float, .C Float, .D Float) { ... }
\end{lstlisting}
The expansion type of \li{\$dataframe} is \li{Dataframe} 
(a type for tabular floating point data together with string row and column keys, consistent with the expression in the expansion above)
and the expansion type of \li{\$cutoffs} is a labeled product of grade cutoffs (Hazel notates labels \li{.label}).
Hazel summarizes this typing information when the cursor is on a livelit name 
in much the same way as it displays a function's type when the variable bound 
to that function is under the cursor.

\subsubsection{Typed Hygienic Splicing and Parameterization} abc

unlike arguments, not a fixed number of splices (e.g. adding a new row or column by pressing those buttons)

\subsubsection{Live Evaluation} abc

\subsection{Case Study: Image Transformations}\label{sec:image-transformation}
Show example of an image transformation pipeline going through livelits

This might also benefit from Parameterization

Show multiple calls with different example images + closure selector UIs

Go into more detail about how evaluation works + fill-and-resume mechanics (and efficiency nod)

Talk about probes?

\subsection{Additional Examples}\label{sec:additional-examples}
It would be nice to have a gallery-style figure and a brief overview of some other case studies
and how they exercise the novel features of the livelits mechanism. Maybe some statistics on how
many lines of code it took.

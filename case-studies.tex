\section{Case Studies}\label{sec:case-studies}
This section introduces livelits from the client programmer's perspective by way of 
two domain-specific case studies:
a course grade assignment case study in Sec.~\ref{sec:live-grading} 
and an image transformation case study in Sec.~\ref{sec:image-transformation}. 
We also briefly mention several other examples in Sec.~\ref{sec:additional-examples}. 
These case studies and examples have been implemented\todo{make this not a lie}{}
in Hazel, a browser-based live programming environment for a pure typed functional language in the
ML family, with which we assume basic familiarity.\todo{cite Elm tutorial for readers who are not familiar?}{} 

\subsection{Case Study: Grading with Livelits}\label{sec:live-grading}
\begin{figure}
\begin{lstlisting}
let grades = $dataframe in 
            A1          A2          A3          A4       Midterm      Final  +
  Cyrus
  Nick
  David
    + 
let averages = compute_averages(grades) in 
let cutoffs = $cutoffs(averages) in 

  |---------------------------------------------------|

format_for_university(assign_grades(averages, cutoffs))
\end{lstlisting}
\caption{Grading Example}
\label{fig:grading}
\end{figure}

Consider this commonplace scenario: an instructor needs 
(1) to record numeric grades for various assignments and exams, and 
(2) to visualize and perform various computations with these numeric grades 
in order ultimately to assign final letter grades (\textbf{A} through \textbf{F}) to the students in the course.

Perhaps the most common end-user application in this domain is the spreadsheet.
A spreadsheet allows the instructor to record student grades using a natural tabular interface,
visualize this data in one of a finite number of styles, and perform basic computations on this data,
with results updated live, i.e. automatically after each cell has been edited. 
However, these affordances are limited. It is difficult to package up common operations and workflows 
into reusable libraries, interact with the data using domain-specific visualizations, 
and perform operations that have not been anticipated by the designers of the spreadsheet system 
(e.g. operations that prepare the data in an idiosyncratic format suitable for automated submission 
to the university's grading system). 
General-purpose programming languages equipped with suitable libraries for working with numeric data
are flexible enough to handle these scenarios, but users of these languages 
sacrifice the ability to receive live feedback and directly manipulate the data and visualizations thereof.

Livelits are able to address this tension. 
Fig.~\ref{fig:grading} shows a Hazel program where the user has:\todo{label each of these 1-5 in figure?}{}
\begin{enumerate}
\item recorded numeric \li{grades} for each student using a livelit, \li{\$dataframe}, that implements a tabular user interface with support for live evaluation of the Hazel expressions in cells, 
\item programmatically computed the overall \li{averages} for each student by applying a function, \li{compute_averages}, defined in a library  (not shown) shared between multiple courses, 
\item determined reasonable \li{cutoffs} between letter grades by directly manipulating a livelit that offers a domain-specific drag-and-drop interface superimposed on a live visualization of the grade distribution 
(for the sake of space, we plot dots rather than a full histogram)\todo{should we do a histogram?}{}, 
\item programmatically assigned letter grades to each student based on the \li{cutoffs} determined in step (3) by calling another shared library function, \li{assign_grades}, 
\item formatted the final grade assignments in a manner suitable for submission to the university system by calling another shared library function, \li{format_for_university}.
\end{enumerate}

\subsubsection{Livelit Expansion} 
Livelit expressions are given dynamic meaning by expansion to core expressions, i.e. expressions that do not contain livelits.
For example, the expansion of Fig.~\ref{fig:grading} is:\todo{change code once figure is final}{}

\begin{lstlisting}
let grades = Dataframe (
  ["A1", "A2", "A3", "A4", "Midterm", "Final"],
  [
    ("Cyrus", [0.0, 0.0, 0.0, 0.0, 0.0]),
    ("Nick", [0.0, 0.0, 0.0, 0.0, 0.0]),
    ("David", [0.0, 0.0, 0.0, 0.0, 0.0])
  ]) in 
let averages = compute_averages(grades) in 
let cutoffs = (.A 90.0, .B 80.0, .C 70.0, .D 60.0) in 
format_for_university(assign_grades(averages, cutoffs))
\end{lstlisting}

The programmer can inspect this expansion in Hazel. 
Ideally, however, it would not be necessary to inspect the expansion 
(or the livelit implementation, which specifies the expansion logic and is discussed in Sec.~\ref{sec:livelit-definitions}) 
to reason about types and binding. 
After all, one does not need to look inside 
function bodies to reason about types and binding.
Instead, in the words of Reynolds\todo{cite}{}, 
``type structure is a syntactic discipline for maintaining levels of abstraction''.
The livelits mechanism supports reasoning abstractly about types and binding by 
several means.

To support abstract reasoning about the type of the expansion, 
livelit definitions declare an \emph{expansion type}.
The declarations of the two livelits in Fig.~\ref{fig:grading}, 
eliding their implementations, are:
\begin{lstlisting}[numbers=none]
livelit $dataframe at Dataframe { ... }
livelit $cutoffs(avgs: List(Float)) 
  at (.A Float, .B Float, .C Float, .D Float) { ... }
\end{lstlisting}
The expansion type of \li{\$dataframe} is \li{Dataframe} 
(a type classifying tabular floating point data together with string row and column keys, consistent with the expansion above)
and the expansion type of \li{\$cutoffs} is a labeled product of grade cutoffs (Hazel notates labels \li{.label}).
Hazel summarizes the typing information from the livelit definition for the programmer when the cursor is on the livelit's name, 
just as it displays a function's type when its name is under the cursor (not shown).\todo{could show if Hannah et al are finished}{}

\subsubsection{Typed Hygienic Splicing and Parameterization} 
Livelit expressions can have sub-expressions provided by the client in one of two ways:
as parameters or as splices. 

\paragraph{Parameters} Parameters appear immediately after the livelit name. 
For example, \li{averages} is provided as a parameter to \li{\$cutoffs} in Fig.~\ref{fig:grading}.
Livelits can declare a fixed number of parameters and specify their types in their declarations. 
For example, the declaration of \li{\$cutoffs} above specifies one parameter of type \li{List(Float)}.
Parameters can be partially applied in livelit abbreviations. For example, consider the slider livelit
from Fig.~\ref{fig:color}:
\begin{lstlisting}[numbers=none]
livelit $slider (min: Float) (max: Float) at Float { ... }
\end{lstlisting}
We can partially apply the first parameter as follows to create a non-negative slider with one remaining parameter:
\begin{lstlisting}[numbers=none]
livelit $nnslider = $slider 0.0 in ...
\end{lstlisting}
The client must provide all remaining parameters to use a livelit to fill a hole in the program.
So writing \li{\$nnslider} in expression position will not display the slider GUI. Instead, it will display as a livelit parameterization error.%
\footnote{In Hazel, erroneous expressions are placed inside holes so that they do not prevent other parts of the program from executing
\cite{HazelnutLive}.}

We can apply both parameters in an abbreviation to create an unparameterized livelit:
\begin{lstlisting}[numbers=none]
livelit $percentage = $slider 0.0 1.0 in ...
\end{lstlisting}

\paragraph{Splices} Splices appear directly inside the livelit GUI.
For example, the column headings and the cells in the \li{\$}

unlike arguments, not a fixed number of splices (e.g. adding a new row or column by pressing those buttons)

\subsubsection{Live Evaluation} abc

\subsection{Case Study: Image Transformations}\label{sec:image-transformation}
Show example of an image transformation pipeline going through livelits

This might also benefit from Parameterization

Show multiple calls with different example images + closure selector UIs

Go into more detail about how evaluation works + fill-and-resume mechanics (and efficiency nod)

Talk about probes?

\subsection{Additional Examples}\label{sec:additional-examples}
It would be nice to have a gallery-style figure and a brief overview of some other case studies
and how they exercise the novel features of the livelits mechanism. Maybe some statistics on how
many lines of code it took.

Ideas:
\begin{itemize}
  \item derivation trees like Joomy's system (\url{https://joom.github.io/proof-tree-builder/src/})
\end{itemize}
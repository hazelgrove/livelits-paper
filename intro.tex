\section{Introduction}
\label{sec:intro}

Programs are most often represented as text.
%
This representation format provides expert programmers access to a variety of
text editors and text edit actions---to affect fine-grained control over
programming decisions---and a large ecosystem of other text-based
utilities---for example, for line-based file differencing of source code
versions.
%
On the other hand, the flexibility and low-level nature of text comes at some
costs.
%
For experts, some tedious and manual edits could lead to
inefficiency---especially because many routine code editing operations do not
require the full flexibility of text~\citep{XXX}.
%
For novices, the large class of syntax errors that stem from text-edits presents
a steep learning curve.

Motivated to overcome the disadvantages of represent programs as text, a variety
of alternative code editing interfaces have been investigated.
%
At the opposite end of text are \emph{visual programming languages}, which often
completely represent a program with graphical elements~\citep{XXX}.
%
To forgo text completely, such approaches often target domain-specific
languages, such as dataflow programing~\citep{XXX} and pedagogical languages
that are, by design, restricted to relatively few building blocks.
%
Other \emph{structure}, or \emph{projectional} editors, still use a significant
amount of text to render programs, but forgo text-edits in favor of
\emph{structure edit actions} which transform the program (represented as a tree
or some other structure), sidestepping the danger of invalid intermediate states
of concrete syntax.

On the spectrum somewhere between fully text- and fully structure-based are
``hybrid'' editors, which augment text with additional ways to visualize and
manipulate the structure of the program.
%
Victor Scrubbing, APX~\citep{APX}, Sketch-n-Sketch~\citep{sns-pldi}, and Carbide
IDE~\citep{XXX}, among others, allow numeric values to be ``scrubbed'' by
directly manipulating sliders rather than text-editing numeric literals.
%
Barista~\cite{Barista} is a hybrid Java editor where custom \emph{structure
view} GUIs provide alternate representations of expressions instead of text.
%
For example, an arithmetic expression may be rendered with mathematical symbols,
a method may be accompanied by interactive documentation with input-output
examples, and structures may be selectively collapsed, expanded, or zoomed.
%
Graphite~\citep{Graphite} allows custom GUIs---called \emph{palettes}---to help
the programmer fill missing expressions---``holes''---in the program.
%
For example, a color palette can provide visual previews of different candidate
color values, and a regular expression palette can show input-output examples
for different candidate regular expressions.

The GUI representations and interactions enabled by the above hybrid editors are
useful, but several limitations likely preclude wider utility:
%
the types of expressions that benefit from alternative GUI editors are limited
to
%
privileged types that have baked-in interfaces~\citep{XXX}
%
or just of base type~\citep{XXX};
%
the GUI view is ephemeral, in that it disappears once it has been used to
generate an expression~\citep{XXX}; or
%
expressions generated by the GUI are not deeply integrated with the static type
system and interpreter of the language~\citep{XXX,XXX,XXX}.


%% refactoring
%% 
%% DNDRefactoring~\citep{DNDRefactoring}
%% Deuce~\citep{sns-deuce}


\parahead{Persistent, Composable, and Live GUIs for Filling Holes}

compared to the ``simple'' palettes

extend palettes with: persistence, composition, and live feedback

macro systems allow alternative syntactic (i.e. string) representations, to
expand into underlying expressions

palatable

by analogy to these ``literal'' macro systems, palettes are ``graphical
macros'': through interaction with the user, the GUI generates the underlying
expression.

TLMs~\cite{TLMs}


\parahead{Contributions and Paper Outline}


design for palettes. specifically, within the Hazelnut Live framework,
which is a system to address the gap problem that arises in traditional editor
frontends.

demonstration of the expressiveness of the approach through a series of
examples, many of which are drawn from the user study mentioned before.

a prototype implementation of palettes within Hazel, which currently
supports several examples using a core calculus with minimal features. the
implementation provides a clear path for scaling up to larger, full-featured
syntactic programming conveniences, as well as further UI design in future work.

hazelnut~\citep{Hazelnut,HazelnutLive}




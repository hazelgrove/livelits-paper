/**
 * The Hazel Incr_dom component.
 * See <https://github.com/janestreet/incr_dom/blob/master/src/app_intf.ml>
 * for the expected interface.
 * See <https://github.com/janestreet/incr_dom/tree/master/example/text_input>
 * for an example-driven overview.
 */
module Js = Js_of_ocaml.Js;
module Dom = Js_of_ocaml.Dom;
module Dom_html = Js_of_ocaml.Dom_html;
module ResizeObserver = Js_of_ocaml.ResizeObserver;
open Incr_dom;

module Model = Model;
module Action = ModelAction;
module State = State;

// see incr_dom app_intf.ml
let on_startup = (~schedule_action, _) => {
  let trigger = (llu, js_str) => {
    /* NOTE(andrew): This is hacky; trying to avoid having to do
     * an extended refactor just to support our temporary use of js for views.
     * Basically: we have no guarantee that the action generated by the user
     * provided js code will be well-formed. So we enclose the conversion in a
     * try block, and just fail silently if the actions is invalid. We also attempt
     * the additional DHExp conversion, as this will be done before the user-provided
     * update fn is called; now we know that call will succeed.
     */
    switch (
      try(
        Some(
          js_str
          |> Js.to_string
          |> Sexplib.Sexp.of_string
          |> SerializedAction.t_of_sexp
          |> DHExp.t_of_sexp,
        )
      ) {
      | _ => None
      }
    ) {
    | None =>
      JSUtil.log("Improperly formed user-defined livelit action");
      ();
    | Some(_) =>
      let serialized_action =
        js_str
        |> Js.to_string
        |> Sexplib.Sexp.of_string
        |> SerializedAction.t_of_sexp;
      schedule_action(ModelAction.LivelitAction(llu, serialized_action));
    };
  };
  Js.Unsafe.set(Dom_html.window, "trigger", Js.wrap_callback(trigger));

  /* we need line heights + character widths for various layout computations,
      so we created a font specimen and update font metrics whenever that
     element resizes. */
  let _ =
    ResizeObserver.observe(
      ~node=JSUtil.force_get_elem_by_id("font-specimen"),
      ~f=
        (entries, _) => {
          let array = Js_of_ocaml.Js.to_array(entries);
          switch (array) {
          | [|entry|] =>
            let rect = entry##.contentRect;
            schedule_action(
              ModelAction.UpdateFontMetrics({
                row_height: rect##.bottom -. rect##.top,
                col_width: rect##.right -. rect##.left,
              }),
            );
          | _ => failwith("Expected 1 entry")
          };
        },
      (),
    );

  /* need to know whether a Mac is being used to determine certain key
     combinations, such as Ctrl+Z vs Cmd+Z for undo */
  let is_mac =
    Dom_html.window##.navigator##.platform##toUpperCase##indexOf(
      Js.string("MAC"),
    )
    >= 0;
  schedule_action(UpdateIsMac(is_mac));

  Dom_html.window##.onfocus :=
    Dom_html.handler(_ => {
      schedule_action(FocusWindow);
      Js._true;
    });
  Dom_html.window##.onblur :=
    Dom_html.handler(_ => {
      schedule_action(BlurWindow);
      Js._true;
    });
  if (JSUtil.window_has_focus()) {
    schedule_action(FocusCell);
  };

  Async_kernel.Deferred.return(State.State);
};

let restart_cursor_animation = caret_elem => {
  caret_elem##.classList##remove(Js.string("blink"));
  // necessary to trigger reflow
  // <https://css-tricks.com/restart-css-animation/>
  let _ = caret_elem##getBoundingClientRect;
  caret_elem##.classList##add(Js.string("blink"));
};

let scroll_cursor_into_view_if_needed = caret_elem => {
  let page_rect =
    JSUtil.force_get_elem_by_id("page-area")##getBoundingClientRect;
  let caret_rect = caret_elem##getBoundingClientRect;
  if (caret_rect##.top < page_rect##.top) {
    caret_elem##scrollIntoView(Js._true);
  } else if (caret_rect##.bottom > page_rect##.bottom) {
    caret_elem##scrollIntoView(Js._false);
  };
};

let scroll_history_panel_entry = entry_elem => {
  let panel_rect =
    JSUtil.force_get_elem_by_id("history-body")##getBoundingClientRect;

  let entry_rect = entry_elem##getBoundingClientRect;
  if (entry_rect##.top < panel_rect##.top) {
    entry_elem##scrollIntoView(Js._true);
  } else if (entry_rect##.bottom > panel_rect##.bottom) {
    entry_elem##scrollIntoView(Js._false);
  };
};

let livelit_sync_queue = ref([]);
let sync_livelit = (a: ModelAction.t): unit => {
  livelit_sync_queue := [a, ...livelit_sync_queue^];
};
let schedule_sync = (~schedule_action: ModelAction.t => unit): unit => {
  List.iter(schedule_action, livelit_sync_queue^);
  livelit_sync_queue := [];
};

let create =
    (
      model: Incr.t(Model.t),
      ~old_model as _: Incr.t(Model.t),
      ~inject: ModelAction.t => Vdom.Event.t,
    ) => {
  open Incr.Let_syntax;
  let%map model = model;

  let performance = model.settings.performance;
  if (performance.measure) {
    Printf.printf("\n== Hazel.create times ==\n");
  };
  TimeUtil.measure_time(
    "Hazel.create", performance.measure && performance.hazel_create, () =>
    Component.create(
      ~apply_action=Update.apply_action(model),
      // for things that require actual DOM manipulation post-render
      ~on_display=
        (_, ~schedule_action) => {
          // if (!Model.get_undo_history(model).disable_auto_scrolling) {
          //   switch (JSUtil.get_elem_by_id("cur-selected-entry")) {
          //   | Some(entry_elem) => scroll_history_panel_entry(entry_elem)
          //   | None => ()
          //   };
          // };
          switch (Model.get_program(model).edit_state.focus) {
          | None => ()
          | Some(_) =>
            // if cell is focused in model, make sure
            // cell element is focused in DOM
            switch (Js.Opt.to_option(Dom_html.document##.activeElement)) {
            | Some(elem) when Js.to_string(elem##.id) == UHCode.root_id => ()
            | _ => UHCode.focus()
            }
          // let caret_elem = JSUtil.force_get_elem_by_id("caret");
          // restart_cursor_animation(caret_elem);
          // scroll_cursor_into_view_if_needed(caret_elem);
          };
          schedule_sync(~schedule_action);
        },
      model,
      Page.view(~inject, ~sync_livelit, model),
    )
  );
};

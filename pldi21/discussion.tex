\section{Discussion and Conclusion}\label{sec:discussion}\label{sec:conclusion}
\begin{quote}
  %
  \textit{
  %
  The arithmetical symbols are written diagrams and the geometrical figures are graphic formulas.
  %
  }
  
  \vspace{3pt}
  
  \hfill{}--- David Hilbert~\cite{hilbert1902mathematical}
  \end{quote}

  \noindent
  Diagrams have played a pivotal role in mathematical thought since antiquity,
  indeed predating symbolic mathematics \cite{cajori1993history}. 
  Popular computing and creative tooling, too, has embraced visual representation and direct manipulation 
  interfaces for decades.
  Programming, however, has remained stubbornly mired in textual user interfaces. 
  % Certainly, one must acknowledge that textual and symbolic notation
  % is an indispensable tool for abstract thought. 
  % Indeed, it is now widely recognized that variables and functions are at the 
  % very foundation of computing. 
  Our hope with this paper is to demonstrate that principled, mathematically structured
  programming is not only compatible with live graphical user interfaces, but that the 
  combination of these two holds promise for the future of programming.

  This paper's contributions are 
  in advancing the expressive power of the mechanism in several directions, 
  most notably in terms of compositionality and liveness. These 
  technical contributions are a complement to the empirical findings by \citet{Graphite} and others.
  That said, the two case studies we considered in this paper were motivated by 
  real world problems. 
  As the implementation
  matures, we plan to introduce enthusiasts in a wide variety of problem domains
  to livelits and continue these empirical evaluations.

  % There remain a number of avenues for future work. First, we have only just started
  % to apply the livelits mechanism in various application domains.  
  % started . 

%   In particular, we would like to better understand the conceptual and practical 
%   difficulties that livelit providers face, with the aim of making livelit 
%   implementation an extremely low cost activity. Livelits could themselves be 
%   useful for this task, if we develop a GUI widget library with support for livelits.
% In addition, recent approaches to deriving type-specific structure editors automatically from pretty printing logic \cite{hempeltiny} could perhaps 
% be adapted to generate livelit implementations. 

Mechanisms for deriving simple 
livelit definitions from type definitions, perhaps similar to Haskell's \li{deriving} directive
or the GEC toolkit \cite{DBLP:conf/afp/AchtenEPW04}, or from \li{to_string} functions \cite{DBLP:conf/vl/HempelC20}, 
may prove fruitful in the future.

  The livelits mechanism as described in this paper operates only on expressions,
  but livelits might be useful for generating other sorts of terms, such as types,
  patterns, and entire modules. Prior work on literal macros has explored this \cite{TLMs}.
  (Note that Racket's visual macro system generates
  arbitrary syntax, so it can already be used in 
  this manner, albeit with no sort-specific semantic guarantees.)
  % Support for type and module splices, too, would likely be useful.
  % With these, better support for reflecting on the provided type might allow for 
  % the development of more general livelits, e.g. a variant of \li{\$datatype} 
  % with individually typed columns, rather than only floating point data.

   The strict hygiene discipline has, we believe, substantial 
   benefits---programmers will inevitably encounter unfamiliar livelits, and 
   the reasoning principles that we enforce are likely to help them ``reason around''
   the situation. However, it may be useful in certain circumstances to 
   relax these, with the editor alerting the user to the unusual situation.

  Another direction for future work has to do with pushing edits from computed results
  back into livelits. For example, a slider expands to a number, which may 
  then flow through a computation. Bidirectional evaluation techniques may allow
  the user to edit a number in the result of a computation and see the necessary
  change to a slider in the program \cite{sns-pldi,sns-uist}.

  Programming and authoring have much in common. Documents often contain structured
  information, and programs are written to manipulate structured information.
  Another future direction for livelits is as the basis for a programmable authoring 
  system, where the non-symbolic elements on the page are revealed to be code after all,
  albeit code generated by a livelit invocation that presents a more natural editing experience. 
  Taking this further, a networked collection of these
  documents could form a powerful computational wiki.
  We present this paper as a foundation for such explorations.
  %  This would 
  % require addressing the difficult problem of supporting collaborative interactions 
  % involving edits to arbitrary user interfaces. 
  % We believe that these problems are surmountable.

% \begin{itemize}
%   \item pattern matching
%   \item type splices
%   \item module splices
%   \item explicitly make bindings available in splices
%   \item better UI for closure provenance / connect with control flow / call stack better
%   \item deriving livelits from type definitions
%   \item bidirectional evaluation ala SnS
%   \item integration with structure editing more cleanly
%   \item \dots
%   \item collaborative editing?
%   \item side effects?
%   \item full screening livelits (or compositions thereof) as a way to create end-user workflows
%   \item big vision: authoring environment based on livelits
% \end{itemize}

\section*{Acknowledgements}

(Acknowledgements are being prepared and will be included in the version sent to the publisher.)
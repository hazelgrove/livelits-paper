\section{Livelit Definitions}\label{sec:livelit-definitions}

\begin{figure}
\begin{lstlisting}[xleftmargin=0.2cm]
type Color = (.r Int, .g Int, .b Int, .a Int)
livelit $color at Color {
  type Model = (.r SpliceRef, .g SpliceRef, 
                .b SpliceRef, .a SpliceRef)

  captures { }

  let init : UpdateMonad(Model) = do 
    r <- new_splice(`Int`, Some(`0`))
    g <- new_splice(`Int`, Some(`0`))
    b <- new_splice(`Int`, Some(`0`))
    a <- new_splice(`Int`, Some(`100`))
    return (r, g, b, a)

  type Action = 
  | ClickOn(Color)

  let view : Model -> ViewMonad(Html(Action)) = 
    fun model -> do 
      (* determine a color to display *)
      r_res <- eval_splice(model.r)
      g_res <- eval_splice(model.g)
      b_res <- eval_splice(model.b)
      a_res <- eval_splice(model.a)
      let cur_color : Color = 
        case (r_res, g_res, b_res, a_res) 
        | (Some(Val(IntLit(r))), 
            Some(Val(IntLit(g))), 
            Some(Val(IntLit(b))), 
            Some(Val(IntLit(a)))) -> 
          Some((r, g, b, a))
        | _ -> 
          (* indetermine color shown as X *)
          None 
      in 
      
      (* generate splice editors *)
      let size = FixedWidth(20) in 
      r_editor <- editor(model.r, size)
      g_editor <- editor(model.g, size)
      b_editor <- editor(model.b, size)
      a_editor <- editor(model.a, size)
      
      (* ... now we can render the UI ... *)
    
  let update : 
      Model -> Action -> UpdateMonad(Model) =
    fun model (ClickOn c) -> do 
      set_splice(model.r, IntLit(c.r))
      set_splice(model.g, IntLit(c.g))
      set_splice(model.b, IntLit(c.b))
      set_splice(model.a, IntLit(c.a))
      return model
  
  let expand : Model -> (Exp, List(SpliceRef)) = 
    fun model -> (`fun r g b a -> (r, g, b, a)`, 
      [model.r, model.g, model.b, model.a])
}
\end{lstlisting}
\vspace{-8px}
\caption{Livelit Implementation}
\label{fig:color-impl}
\end{figure}

\noindent
We now take the perspective of a livelit provider.\todo{line num pass}{}
Fig.~\ref{fig:color-impl}
defines \li{\$color} from Fig.~\ref{fig:color}(b). We omit certain 
incidental details and use unimplemented syntactic sugar, including
Haskell-style \li{do} notation and quasiquotation, for presentation.

Livelit definitions are scoped and packaged like 
any other definition. They consist of a declaration and an implementation. 
Line 3 of Fig.~\ref{fig:color-impl} is \li{\$color}'s declaration,
which defines its name and its {expansion type}. 
Livelit parameters would also appear here. 
The declaration is part of the client interface, 
as discussed in Sec.~\ref{sec:expansion-typing}-\ref{sec:parameterization}. 

\subsection{Livelit Implementations}
The curly braces delimit the livelit's implementation. 
Livelits are implemented using a variation on the functional model-view-update
architecture popularized by the Elm language, upon which Hazel is based \cite{ElmArchitecture}. We add a fourth component,
expansion generation. In addition, we add a simple monadic framework (\emph{a la} Haskell\todo{citation}{}) to provide the necessary  
interface between the livelit and the programming environment, while retaining
a pure functional programming model. (We discuss imperative languages in Sec.~\ref{sec:imperative-langs}.)


\subsubsection{Model}\label{sec:model}
The state of a livelit invocation is encoded in its model value. 
Line 4 of Fig.~\ref{fig:color-impl} specifies the livelit's \emph{model type},
here a labeled 4-tuple of \emph{splice references}, one for each of the four splices
that appear in the GUI in Fig.~\ref{fig:color}.
The model is how the livelit state is persisted in the syntax tree, so 
 the system requires that the model type supports automatic serialization
 (so, no functions in models).

The \li{init} value on Line 9 determines the value of the model
when the livelit is first invoked in the editor.
It is a command in the \li{UpdateMonad}, discussed below, that returns the 
initial model value after generating four new splices 
using the \li{new_splice} command:
\begin{lstlisting}[numbers=none]
new_splice : (Typ, Maybe(Exp)) 
             -> UpdateMonad(SpliceRef)
\end{lstlisting}
This command creates a splice
of the given type and, optionally, specifies its initial contents. 
It returns a splice reference, which uniquely identifies that splice.
Bolded types  
are defined in the standard library. The \li{Typ} and \li{Exp} types 
encode the syntax of Hazel's types and expressions.
These two arguments are expressed here using quasiquotes, e.g. \li{`0`} \cite{bawden1999quasiquotation}. 
% If no initial expression is provided, the splice starts as  
% an empty hole.

The system checks that the splice type and initial content are valid 
assuming only the parameters and explicitly specified set of captured bindings on Line 7.
Here, the capture set is empty because \li{Int} is a built in type
and the initial content is closed. 
This serves to ensure \emph{context independence}: the livelit needs to make no 
assumptions about the typing context at invocation sites.
We use an explicit capture set, rather than implicitly capturing all bindings 
at the definition site, 
to ensure that private bindings are not unintentionally  
leaked to clients as detailed by \citet{TLMs}.
% Formally, captured variables can be understood as parameters that have been 
% immediately partially applied.

\subsubsection{Action}
Line 14 defines the \li{Action} type for the \li{\$color} livelit, which 
specifies a single user-initiated action: clicking on a color using
the right side of Fig.~\ref{fig:color}(b). Actions are emitted
from event handlers (e.g. click handlers) defined in the computed \li{view}, 
and actions are consumed by the \li{update} function, causing a change to the model. 
Let us discuss each of these functions in turn in Sec.~\ref{sec:def-view}-\ref{sec:def-update}.

\subsubsection{View}\label{sec:def-view}
The \li{view} function computes the view given a model and access to the commands in 
the \li{ViewMonad}. The computed view is a value of type \li{Html(Action)}.  
The type family \li{Html(a)} provides a simple immutable
encoding of an HTML tree, where the type parameter \li{a} is the type of actions that 
are emitted by event handlers that can be attached to elements of the tree, e.g.
\li{on_click} and so on. 
We elide the details of the particular user interface in Fig.~\ref{fig:color}
to focus on three key editor mechanisms exposed by \li{ViewMonad}: live evaluation,
splice editors, and result rendering.

\paragraph{Live Evaluation}
\label{sec:live-evaluation-def}
As discussed in Sec.~\ref{sec:live-evaluation}, 
the view can depend on the result of evaluating a splice 
under the closure the client has selected.
The interface between the view and the live evaluator 
is via the 
following command:
% Actually, it can depend on an encoded function of 
% multiple splices as long as the function is well-typed using only the capture set, 
% under the closure that the client has selected using one of the following
% commands:
\begin{lstlisting}[numbers=none,xleftmargin=0cm]
eval_splice : SpliceRef -> ViewMonad(Maybe(Result))
\end{lstlisting}

%eval_fun : (Exp, List(SpliceRef)) -> ViewMonad(Maybe(Result))

The \li{None} case 
arises when evaluation is not possible, e.g. because no closures are collected.
% because the free variables in the selected closure overlap with the free 
% variables in the provided expression. This occurs only when the user has selected
% a closure that appears under a binder in the evaluation result (e.g. because 
% the result is a lambda). 
% We discuss this further in Sec.~\ref{sec:calculus-closure-collection}.
If a result is available, the \li{Result} type distinguishes two possibilities:
\begin{lstlisting}[numbers=none]
type Result = Val(Exp) | Indet(Exp)
\end{lstlisting}
The \li{Val} case arises when evaluation produces a value, whereas the 
\li{Indet} case arises when evaluation results in an indeterminate expression,
i.e. an expression that cannot be fully evaluated due to holes 
in critical positions \cite{HazelnutLive}.

Lines X-Y determine a color to display in the color preview 
if all four splices evaluate to integers. Otherwise, there is not 
enough information to determine a color. The livelit 
communicates this indeterminacy with an ``X'' over the preview.

Livelits can attempt to offer feedback even when the result is indeterminate,
because indeterminate expressions might nevertheless contain useful information.
For example, a livelit that previews a sequence of notes as audio might be able 
to handle a list of notes where certain notes are missing, i.e. holes, by 
simply playing silence or some default sound when it encounters them.
This behavior is highly domain-specific, so each livelit provider must decide 
whether and how indeterminate results are supported.

\paragraph{Splice Editors}
The view includes an editing area for each splice. These editors must support all of 
Hazel's editing services. To support this, the \li{view} function
can request an editor with a given dimension (in character units) for a given splice:
\begin{lstlisting}[numbers=none]
editor : (SpliceRef, Dim) -> ViewMonad(Html(a))
\end{lstlisting}
The result is an opaque \li{Html(a)} value that the remainder of the function 
can place where needed. When the livelit is rendered, this part of the tree is 
under the control of Hazel. The \li{Dim} parameter currently supports only a fixed
character width, with overflow causing scrolling, but in the future we plan to offer 
to offer more flexible layout options.

\paragraph{Result Rendering}
Some livelit views needs to include 
a rendered evaluation result. For example, each of the cells in the \li{\$dataframe}
livelit in Fig.~\ref{fig:grading} shows the evaluation result for the corresponding 
cell. Only the formula bar at the top is an editor. To support this, the \li{view}
function can use the \li{result_view} command, which mirrors the \li{eval} command:
\begin{lstlisting}[numbers=none]
result_view : 
  (SpliceRef, Dim) -> ViewMonad(Maybe(Html(a)))
\end{lstlisting}


\subsubsection{Update}\label{sec:def-update}
When the user triggers an event in a livelit view, it emits an \li{Action}.
The system responds by calling the \li{update} function to determine how 
this action should affect the model and, in some cases, the splices. 

% We discussed in Sec.~\ref{sec:model} that the \li{UpdateMonad}
% allows new splices to be generated in response to user actions. 
% For example, the \li{\$dataframe} livelit uses this when new rows
% or columns are added.

In Fig.~\ref{fig:color-impl}, we see that the \li{\$color} livelit responds to 
the \li{ClickOnColor} action by invoking the \li{set_splice} command to overwrite 
the current splices with integer literals determined based on which color the user
clicked on:
\begin{lstlisting}[numbers=none]
  set_splice : (SpliceRef, Exp) -> UpdateMonad ()
\end{lstlisting}
The system checks that the expression must satisfy the splice type 
and onlys make use of the capture set, as in Sec.~\ref{sec:model}.

When the model is updated, a new view is 
computed. The system then performs a diff between the old and new view in order to 
efficiently perform the necessary imperative updates to the editor's visual state.
Changes to splices can also cause the view to be recomputed, because the view might 
evaluate the splices. The \li{update} function does not itself 
have the ability to request evaluation, because the model should not depend directly  
on which closure the user has selected. 
%Of course, the \li{view} might emit 
%result-dependent actions when appropriate.

\subsubsection{Expansion}
\label{sec:expansion}
The ultimate purpose of a livelit is to fill the hole where it appears by generating an expansion,
i.e. an expression of the expansion type, here \li{Color}.
The \li{expand} function determines this expansion based on the model.

The expansion can include splices, but the system does not make the contents of a splice 
available directly as a value of type \li{Exp}. Instead, \li{expand} returns a \emph{parameterized expansion}
paired with a list of \li{SpliceRef}s. 
The {parameterized expansion}
 is an encoding (of type \li{Exp}) of a function 
 that takes an argument for each listed \li{SpliceRef}s. 
 That argument is of the corresponding splice 
type, which was provided when the splice was initialized. 
 The return type of the parameterized expansion is the expansion type.
 Here, the parameterized expansion for \li{\$color} encodes a function of type 
 \li{Int -> Int -> Int -> Int -> Color}.

This parameterization strategy makes it simple to enforce hygiene: the parameterized expansion 
can depend only on the livelit parameters and capture set, whereas the splices are entered by the client and so they can 
depend only on the client site typing context. The use of function application ensures
that splices are capture avoiding. We consider this more formally in the next section.
